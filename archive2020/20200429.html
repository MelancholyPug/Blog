<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<script src="/_resource/js/_js_initialLoadFiles.min.js"></script>
</head>
<body>

  <h1>C#多重字串（陣列）比對的寫法</h1>

  <p>不是甚麼技術性的文章，就單純紀錄以前跟後期的寫法習慣，以後大概都會用Linq Any()來縮減語法描述的複雜性了。</p>

  <h3>IndexOf()寫法</h3>
<pre>
string cSearch = "John";
if ("John1,John2,Marry,Adam".IndexOf(cSearch) >= 0)
{ Console.WriteLine($"找到{cSearch}了。"); }
</pre>
<p>這樣的寫法其實也沒啥大問題，但唯一的問題就是沒有辦法進行完全相等的比對，以上面的範例來說，當我們需要真的比對「John」這個人時，其實這個程式就變得很有問題了，所幸大部分多重字串的比對場景其實都是模糊的居多。（至少我遇到的經驗是如此）</p>
  <p>P.S 或許會有人覺得用IndexOfAny()就好，可是這個只有適用於Char搜尋喔。</p>

  <h3>Linq .Any()寫法</h3>
  <p>改成用Linq的思維來重寫多重字串命中符合的搜尋邏輯，一切就變得合理多了。</p>
<pre>
string cSearch = "John";
if (new string[] {"John1", "John2", "Marry", "Adam"}.Any(x =&gt; x.Contains(cSearch)))
{ Console.WriteLine($"找到{cSearch}了。"); }
</pre>

<p>改成完全命中符合當然是易如反掌了：</p>
<pre>
string cSearch = "John";
if (new string[] {"John1", "John2", "Marry", "Adam"}.Any(x =&gt; x == cSearch))
{ Console.WriteLine($"找到{cSearch}了。"); }
else
{ Console.WriteLine($"找不到{cSearch}。"); }
</pre>

  <small>C# CSharp MultiString StringArray Search Compare System.Linq Any()</small>

</body>
</html>